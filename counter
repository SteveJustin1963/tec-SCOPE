
;;;;;up count;;;;;;;;;;;;;;;;;;;;

; Start of the program
ORG 0x0000  ; Origin, set program start address

START:  ; Entry point of the program

; Initialize HL, DE to 0000
LD HL, 0
LD DE, 0

; Loop to increment HL and handle overflow
COUNT_LOOP:
    ; Increment HL
    INC HL

    ; Check if HL has reached FFFF (0xFFFF)
    LD A, L   ; Load the least significant byte of HL into A
    CP 0xFF   ; Compare A with 0xFF
    JP NZ, CONTINUE  ; If not, continue

    LD A, H   ; Load the most significant byte of HL into A
    CP 0xFF   ; Compare A with 0xFF
    JP NZ, CONTINUE  ; If not, continue

    ; Overflow occurred, increment E and check for overflow in DE
    INC E
    LD A, E
    CP 0x00
    JP NZ, DE_NO_OVERFLOW

    ; If E overflowed, increment D and reset E
    INC D
    LD A, D
    CP 0x00
    JP NZ, DE_NO_OVERFLOW

    ; If D also overflowed, reset DE
    LD DE, 0

DE_NO_OVERFLOW:

CONTINUE:
    ; Continue counting since HL will naturally overflow to 0000
    JP COUNT_LOOP  ; Jump back to the beginning of the loop

END:
    ; Your program ends here
    HALT  ; Halt the CPU

END  ; End of the program




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;down count;;;;;;;;;;;;;;;;

ORG 0000h  ; The origin address of your program

START:
    LD  BC, 65535  ; Load BC with the initial value FFFFh (65535 in decimal)

LOOP:
    ; Check if BC has reached zero (0000h)
    LD  A, C       ; Load the lower byte of BC into register A
    OR  B          ; Logical OR with the higher byte of BC (B)
    JP  Z, DONE    ; If A is zero (BC == 0000h), exit the loop

    ; Decrement BC
    DEC BC

    ; Add delay or other instructions here if needed

    ; Jump back to the loop
    JP  LOOP

DONE:
    ; Your code to measure the time here and display it

    ; End the program
    HALT

    ; Additional code and data go here

    END  ; End of program


